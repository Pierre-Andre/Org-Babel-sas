* How to use this org file
This org file  can give several "src" files :
- ob-sas.el : an elisp file
- example_windows.emacs : an elisp ".emacs" example for windows


tangle 1 file :
put cursor on the chosen src block and issue the following shortcut
C-u C-u C-c C-v t
It tangles the whole file which name is given in the tangle argument (on the #+BEGIN_SRC line)

tangle only one block (the current block)
C-u C-c C-v t

tangle whole buffer (which gives several files)
C-c C-v t
* todo
** liste des functions pour eliminer ess
*** =ess-eval-buffer=
permet d'evaluer le bloc src
mais la chaine d'appel est la suivante
ess-eval-buffer -> ess-eval-region -> ess--eval-region ->  ess-eval-region--normalise-region + ess-send-region -> ess-send-string

#+begin_src emacs-lisp
(defun ess-eval-region--normalise-region (start end)
  "Clean the region from START to END for evaluation.
This trims newlines at beginning and end of the region because
they might throw off the debugger."
  (save-excursion
    (goto-char start)
    (skip-chars-forward "\n\t ")
    (setq start (point))
    (unless mark-active
      (ess-blink-region start end))
    (goto-char end)
    (skip-chars-backward "\n\t ")
    (setq end (point))))
#+end_src
*** =ess-send-string=
#+begin_src emacs-lisp
(defun ess-send-string (process string &optional visibly message _type)
  "ESS wrapper for `process-send-string'.
Run `comint-input-filter-functions' and current buffer's and
PROCESS' `ess-presend-filter-functions' hooks on the input
STRING. VISIBLY can be nil, t, 'nowait or a string.  If string
the behavior is as with 'nowait with the differences that
inserted string is VISIBLY instead of STRING (evaluated command
is still STRING).  In all other cases the behavior is as
described in `ess-eval-visibly'. STRING need not end with
\\n. TYPE is a symbol indicating type of the string.
MESSAGE is a message to display."
  ;; No support of `visibly' when there's no secondary prompt
  (let ((visibly (if (and (eq visibly t)
                          (null inferior-ess-secondary-prompt))
                     'nowait
                   visibly))
        (string (ess--run-presend-hooks process string)))
    (inferior-ess--interrupt-subjob-maybe process)
    (inferior-ess-mark-as-busy process)
    (process-put process 'last-eval (current-time))
    (cond
     ;; Wait after each line
     ((eq visibly t)
      (let ((ess--inhibit-presend-hooks t))
        (ess-eval-linewise string)))
     ;; Insert command and eval invisibly
     ((or (stringp visibly)
          (eq visibly 'nowait))
      (with-current-buffer (process-buffer process)
        (save-excursion
          (goto-char (process-mark process))
          (insert-before-markers
           (propertize (format "%s\n"
                               (replace-regexp-in-string
                                "\n" "\n+ "
                                (if (stringp visibly) visibly string)))
                       'font-lock-face 'comint-highlight-input)))
        (process-send-string process (ess--concat-new-line-maybe string))))
     (t
      (process-send-string process (ess--concat-new-line-maybe string))))
    (when message
      (message "%s" message))))

#+end_src
permet d'envoyer le string de fin
=inferior-ess-send-string=
*** =org-babel-sas--send-string=
**** tout d'abord  le nettoyage de la commande
#+begin_src emacs-lisp
(defun org-babel-sas--concat-new-line-maybe (string)
  "Append \\n at the end of STRING if missing."
  (if (string-match "\n\\'" string (max (- (length string) 2) 0))
      string
    (concat string "\n")))
#+end_src
**** ensuite l'envoi de la commande
#+begin_src emacs-lisp
(defun org-babel-sas--send-string (process string)
  "Send string to process using process-send-string"
(process-send-string process (org-babel-sas--concat-new-line-maybe string)))
#+end_src
**** reste le demmarage du process
The fundamental building blocks for interacting with processes are =start-process=, for kinda-sorta-asynchronous process calls; and =call-process=, for synchronous process calls.
#+begin_src emacs-lisp
(start-process )
#+end_src
**** autre possibité: comint
https://www.masteringemacs.org/article/comint-writing-command-interpreter
https://www.emacswiki.org/emacs/ComintMode

https://stackoverflow.com/questions/13620498/why-emacs-comint-mode-doesnt-process-string-as-shell
https://stackoverflow.com/questions/44937294/get-result-back-from-comint-redirect-send-command
** variable
*** =ess-eval-visibly-p=
#+begin_src emacs-lisp
(defcustom ess-eval-visibly 'nowait
  "Non-nil means ess-eval- commands display commands in the process buffer.
If 'nowait, ESS shows input commands in the process buffer, but
doesn't wait for the process. Thus all the output is printed
after the input lines.

If t, ESS waits after each line of the command for the process
output. This results in a nice sequence of input and output but
stalls Emacs on long output (like Sys.sleep(5) in R).

If nil, ESS doesn't print input commands and doesn't wait for the
process.

This variable also affect the evaluation of input code in
iESS. The effect is similar to the above. If t then ess waits for
the process output, otherwise not."
  :group 'ess-proc
  :package-version '(ess . "19.04")
  :type '(choice (const t) (const nowait) (const nil)))
#+end_src
*** =ess-local-process-name=
#+begin_src emacs-lisp
(defvar-local ess-local-process-name nil
  "The name of the ESS process associated with the current buffer.")
#+end_src
*** =ess-ask-for-ess-directory=
ess-custom.el
#+begin_src emacs-lisp
(defcustom ess-ask-for-ess-directory t
  "Non-nil means request the process directory each time S is run."
  :group 'ess
  :type 'boolean)
#+end_src

 f
** comint
make-comint-in-buffer ->  comint-exec -> comint-exec-1 -> start-file-process -> start-process -> make-process
pour separer input et output il faut faire
https://emacs.stackexchange.com/questions/17394/discard-stderr-in-start-process
*** gloubi
#+begin_src emacs-lisp
make-process :name "sas"
              :buffer (generate-new-buffer "*sas*")
              :command '("mplayer" "/path/to/video")
              :connection-type 'pipe
              :stderr (generate-new-buffer "*sas err*"))
#+end_src
mais dans start-process c'est pas propose
-> alternative avec program-args qui a une liste
("-s" "blabla")
ou une plist
(:switches ("-s" "blabla") :stderr "*sas err*")
#+begin_src emacs-lisp
;(if (not (plist-get '("-s" "blabla") ':stderr)) "yes")
(plist-get '(:switches ("-nodms" "-nonews" "-stdio"
                            "-nofullstimer" "-nodate" "-nocenter"
                            "-terminal" "-pagesize" "max"
                            "-nosyntaxcheck") :stderr "*sas err*") ':switches)
(plist-get (list :switches  sas-cli-arguments ':stderr "*sas err*") ':switches)
#+end_src

#+RESULTS:
| -nodms | -nonews | -stdio | -nofullstimer | -nodate | -nocenter | -terminal | -pagesize | max | -nosyntaxcheck |

#+begin_src emacs-lisp :results none
(defun his-tracing-function (orig-fun &rest args)
  (message "comint-exec-1  called with args %S" args)
  (let ((res (apply orig-fun args)))
    (message "display-buffer returned %S" res)
    res))
(defun his-tracing-function1 (orig-fun &rest args)
  (message "start-file-process  called with args %S" args)
  (let ((res (apply orig-fun args)))
    (message "display-buffer returned %S" res)
    res))


(advice-add 'comint-exec-1   :around #'his-tracing-function)
(advice-add 'start-file-process   :around #'his-tracing-function1)
(run-sas)
#+end_src



#+begin_src emacs-lisp
(defvar sas-cli-file-path "/usr/local/bin/sas_u8"
  "Path to the program used by `run-sas'")
(defvar sas-cli-arguments '("-nodms" "-nonews" "-stdio"
                            "-nofullstimer" "-nodate" "-nocenter"
                            "-terminal" "-pagesize" "max"
                            "-nosyntaxcheck"))
                             (append '(sas) sas-cli-arguments)
#+end_src

#+RESULTS:
| sas | -nodms | -nonews | -stdio | -nofullstimer | -nodate | -nocenter | -terminal | -pagesize | max | -nosyntaxcheck |

**** via comint avec log+output mélangé: =run-sas=
#+begin_src emacs-lisp :results none
(defun run-sas ()
  "Run an inferior instance of `sas' inside Emacs."
  (interactive)
  (let* ((sas-program sas-cli-file-path)
         (buffer (comint-check-proc "sas")))
    ;; pop to the "*sas*" buffer if the process is dead, the
    ;; buffer is missing or it's got the wrong mode.
    (pop-to-buffer-same-window
     (if (or buffer (not (derived-mode-p 'inferior-sas-mode))
             (comint-check-proc (current-buffer)))
         (get-buffer-create (or buffer "*sas*"))
       (current-buffer)))
    ;; create the comint process if there is no buffer.
    (unless buffer
      (apply 'make-comint-in-buffer "sas"
                                                  buffer sas-program nil sas-cli-arguments )
                                            (inferior-sas-mode))))
#+end_src
* inferior-sas-mode
** Idea
The main idea of sas.el is to provide a way to send SAS program from emacs
buffer to SAS program and to get the results and to have a syntaxic coloration in the buffer.

Buffer Emacs -----> SAS : results (and log/errors)
*** Inferior mode

1. The classical way to interact is to setup an "inferior" SAS process with an
   associated buffer using comint. In that inferior buffer, the user types its
   command send them (using RET) and get the results or the errors.

   As comint don't provide a way to separate results (SAS output) from standard
   error (ie SAS log) the classical output have them both (and it is a little
   bit messy) in the associated SAS buffer. This SAS buffer is in
   inferior-sas-mode which inherits from comint-mode


                       SAS process
   Buffer Emacs ----->     +
                       SAS buffer
                   (inferior-sas-mode)

2. Another way is to separate the associated buffer in two part: the std output
   (SAS results) and the std error (SAS log) each in separate buffers

                                       SAS process
    Buffer Emacs ----->                     +
                        SAS buffer (output) & SAS buffer std error (log)
                        (inferior-sas-mode)

   To achieve this, the whole function composition is provided with an
   supplementary argument to have this std error redirected in another buffer

    make-comint-in-buffer-std ->  comint-exec-std -> comint-exec-1-std -> start-file-process-std -> start-process-std -> make-process (provided by emacs)

Starting the inferior mode buffer is done with =run-sas=. This function is the
same as =run-python= except that the user can choose the name of the inferior
SAS buffer (useful for org babel src_block and =:session= argument) and to have
a separate std error buffer.
*** SAS mode
It is the major mode providing
- syntaxic coloration
  inherits from ESS code
- functions to send code to SAS
  and a thus a way to identify SAS buffer
- keyboard shortcuts
**** Sending code to SAS
The idea is to set some functions to send line/region/buffer and a "do what I mean"
(dwim) function. The latter will send a block around the point (the cursor): the block
is either the proc or the data block where the cursor is (exception in proc IML where
it is the line). The flow is the following:

sas-send-line
sas-send-region    --- > sas-send-string ---> comint-send-string ---> results in SAS buffer
sas-send-buffer                                                        associated with SAS
sas-send-dwim

These function send a string to the inferior SAS buffer and to the SAS program
**** Identifying the sas buffer
I follow the python-mode scheme: the buffer is either a global buffer (One SAS inferior buffer for all) or a dedicated
SAS inferior buffer for the given buffer

_Dedicated_
SAS buffer "program1.sas"              SAS process
where is the program 1          ---->      +
(sas-mode)                             SAS buffer dedicated for program 1

SAS buffer "program2.sas"              SAS process
where is the program 2          ---->      +
(sas-mode)                             SAS buffer dedicated for program 2

_Global_
SAS buffer "program1.sas"
where is the program 1     \
(sas-mode)                  \
                             \
SAS buffer "program2.sas"     \         SAS process
where is the program 2      ---\---->      +
(sas-mode)                             the global SAS buffer

Moreover the dedicated buffer have a name chosen as =*sas output[program1]*=
(and =*sas log[program1]*=).

** output+error in the same buffer
pour avoir que des erreurs
https://documentation.sas.com/doc/da/pgmsascdc/9.4_3.5/basess/p0rgzxi5r1euj0n14epck6v9l2hm.htm
=options nosource nonotes errors=0;=

avec cela on peut faire du comint de base et via tramp.
** fonctions
make-comint-in-buffer-std ->  comint-exec-std -> comint-exec-1-std -> start-file-process-std -> start-process-std -> make-process
avec la possibilite de separer le std error (ie sas log)
#+begin_src emacs-lisp :results none :tangle inferior-sas.el
(defun make-comint-in-buffer-std (name buffer program &optional startcommand stderr &rest switches)

  "Make a Comint process NAME in BUFFER, running PROGRAM.
If BUFFER is nil, it defaults to NAME surrounded by `*'s.
If there is a running process in BUFFER, it is not restarted.

PROGRAM should be one of the following:
- a string, denoting an executable program to create via
  `start-file-process'
- a cons pair of the form (HOST . SERVICE), denoting a TCP
  connection to be opened via `open-network-stream'
- nil, denoting a newly-allocated pty.

Optional fourth arg STARCOMMAND is string whose
contents are sent to the process as its initial input.
Optional fifth arg STDERR is a buffer for standard error.

If PROGRAM is a string, any more args are arguments to PROGRAM.

Return the (possibly newly created) process buffer."
  (or (fboundp 'start-file-process)
      (error "Multi-processing is not supported for this system"))
  (setq buffer (get-buffer-create (or buffer (concat "*" name "*"))))
  ;; If no process, or nuked process, crank up a new one and put buffer in
  ;; comint mode.  Otherwise, leave buffer and existing process alone.
  (unless (comint-check-proc buffer)
    (with-current-buffer buffer
      (unless (derived-mode-p 'comint-mode)
        (comint-mode))) ; Install local vars, mode, keymap, ...
    (comint-exec-std buffer name program startcommand stderr switches))
  buffer)

(defun comint-exec-std (buffer name command startcommand stderr switches)
  "Start up a process named NAME in buffer BUFFER for Comint modes.
Runs the given COMMAND with SWITCHES, initial input from STARTCOMMAND and standard error from STDERR.

COMMAND should be one of the following:
- a string, denoting an executable program to create via
  `start-file-process'
- a cons pair of the form (HOST . SERVICE), denoting a TCP
  connection to be opened via `open-network-stream'
- nil, denoting a newly-allocated pty.

This function blasts any old process running in the buffer, and
does not set the buffer mode.  You can use this to cheaply run a
series of processes in the same Comint buffer.  The hook
`comint-exec-hook' is run after each exec."
  (with-current-buffer buffer
    (let ((proc (get-buffer-process buffer)))	; Blast any old process.
      (if proc (delete-process proc)))
    ;; Crank up a new process
    (let ((proc
           (if (consp command)
               (open-network-stream name buffer (car command) (cdr command))
             (comint-exec-1-std name buffer command stderr switches))))
      (set-process-filter proc 'comint-output-filter)
      (setq-local comint-ptyp process-connection-type) ; t if pty, nil if pipe.
      ;; Jump to the end, and set the process mark.
      (goto-char (point-max))
      (set-marker (process-mark proc) (point))
      (cond (startcommand
        (sleep-for 1)
	     (goto-char (point-max))
          (comint-send-string proc startcommand)))
      (run-hooks 'comint-exec-hook)
      buffer)))

(defun comint-exec-1-std (name buffer command stderr switches)
  "Same function as `comint-exec-1' but with STDERR argument: a buffer to which will be used as standard error of process (see `make-process')"
  (let ((process-environment
         (nconc
          (comint-term-environment)
          (list (format "INSIDE_EMACS=%s,comint" emacs-version))
          process-environment))
        (default-directory
          (if (file-accessible-directory-p default-directory)
              default-directory
            "/"))
        proc decoding encoding changed)
    (let ((exec-path (if (and command (file-name-directory command))
                         ;; If the command has slashes, make sure we
                         ;; first look relative to the current directory.
                         (cons default-directory exec-path) exec-path)))
      (setq proc (apply 'start-file-process-std name buffer command stderr switches)))
    ;; Some file name handler cannot start a process, fe ange-ftp.
    (unless (processp proc) (error "No process started"))
    (let ((coding-systems (process-coding-system proc)))
      (setq decoding (car coding-systems)
            encoding (cdr coding-systems)))
    ;; Even if start-file-process left the coding system for encoding data
    ;; sent from the process undecided, we had better use the same one
    ;; as what we use for decoding.  But, we should suppress EOL
    ;; conversion.
    (if (and decoding (not encoding))
        (setq encoding (coding-system-change-eol-conversion decoding 'unix)
              changed t))
    (if changed
        (set-process-coding-system proc decoding encoding))
    proc))

(defun start-file-process-std (name buffer program stderr &rest program-args)
  "Start a program in a subprocess.  Return the process object for it.

Similar to `start-process', but may invoke a file name handler based on
`default-directory'.  See Info node `(elisp)Magic File Names'.

This handler ought to run PROGRAM, perhaps on the local host,
perhaps on a remote host that corresponds to `default-directory'.
In the latter case, the local part of `default-directory', the one
produced from it by `file-local-name', becomes the working directory
of the process on the remote host.

PROGRAM and PROGRAM-ARGS might be file names.  They are not
objects of file name handler invocation, so they need to be obtained
by calling `file-local-name', in case they are remote file names.

STDERR is a buffer which will be used as standard error of process (see `make-process')

File name handlers might not support pty association, if PROGRAM is nil."
  (let ((fh (find-file-name-handler default-directory 'start-file-process-std)))
    (if fh (apply fh 'start-file-process-std name buffer program stderr program-args)
      (apply 'start-process-std name buffer program stderr program-args))))

(defun start-process-std (name buffer program stderr &rest program-args)
  "Start a program in a subprocess.  Return the process object for it.
NAME is name for process.  It is modified if necessary to make it unique.
BUFFER is the buffer (or buffer name) to associate with the process.

Process output (both standard output and standard error streams)
goes at end of BUFFER, unless you specify a filter function to
handle the output.  BUFFER may also be nil, meaning that this
process is not associated with any buffer.

PROGRAM is the program file name.  It is searched for in `exec-path'
\(which see).  If nil, just associate a pty with the buffer.  Remaining
arguments PROGRAM-ARGS are either strings to give program as arguments or
a plist (:stderr \"*buffer name of stderr*\" :switches (\"-l\" \"-a\"))

STDERR is a buffer for separate standard output from standard error.

The process runs in `default-directory' if that is local (as
determined by `unhandled-file-name-directory'), or \"~\"
otherwise.  If you want to run a process in a remote directory
use `start-file-process'."
  (unless (fboundp 'make-process)
    (error "Emacs was compiled without subprocess support"))
  (apply #'make-process
         (append (list :name name :buffer buffer)
                 (if program
                     (if stderr
                         (list :command (cons program program-args)
                               :stderr stderr)
                       (list :command (cons program program-args)))
                   )))  )
#+end_src
** demarrage du mode
qqch de tres basique:
#+begin_src emacs-lisp :results none :tangle inferior-sas.el
(defun run-sas ()
  "Run an inferior instance of `sas' inside Emacs."
  (interactive)
  (let* ((sas-program sas-cli-file-path)
         (buffer (comint-check-proc "*sas*")))
    ;; pop to the "*sas*" buffer if the process is dead, the
    ;; buffer is missing or it's got the wrong mode.
    (pop-to-buffer-same-window
     (if (or buffer (not (derived-mode-p 'inferior-sas-mode))
             (comint-check-proc (current-buffer)))
         (get-buffer-create (or buffer "*sas*"))
       (current-buffer)))
    ;; create the comint process if there is no buffer.
    (unless buffer
      (apply 'make-comint-in-buffer-std "sas"
             buffer sas-program (generate-new-buffer "*sas errors*") sas-cli-arguments )
      (inferior-sas-mode))))
(run-sas)
#+end_src
*** Python
ou mieux =run-python= et =python-shell-make-comint=
*** Ess
R ->  run-ess-r ->
inferior-ess -> inferior-ess--start-process -> comint-exec -> comint-exec-1 -> start-file-process -> start-file
** variables
#+begin_src emacs-lisp :results none :tangle sas-inferior.el
(defvar sas-cli-file-path "/usr/local/bin/sas_u8"
  "Path to the program used by `run-sas'")
(defvar sas-cli-arguments '("-nodms" "-nonews" "-stdio"
                            "-nofullstimer" "-nodate" "-nocenter"
                            "-terminal" "-pagesize" "max"
                            "-nosyntaxcheck")
  "Commandline arguments to pass to `sas-cli'.")
;; to print sas options list add "-oplist" to sas-cli-arguments
(defvar sas-prompt-regexp "^"
  "Prompt for `run-sas'.")
(defun sas--initialize ()
  "Helper function to initialize Sas"
  (setq comint-process-echoes t)
  (setq comint-use-prompt-regexp t))

(define-derived-mode inferior-sas-mode comint-mode "Inferior sas"
  "Major mode for sas inferior process`run-sas'."
  nil "sas"
  ;; this sets up the prompt so it matches things like: [foo@bar]
  (setq comint-prompt-regexp sas-prompt-regexp))
;; this makes it read only; a contentious subject as some prefer the
;; buffer to be overwritable.
;; (setq comint-prompt-read-only t)
;; (setq comint-process-echoes t)
;; this makes it so commands like M-{ and M-} work.
;; (set (make-local-variable 'paragraph-separate) "\\'")
;; (set (make-local-variable 'font-lock-defaults) '(sas-font-lock-keywords t))
;; (set (make-local-variable 'paragraph-start) sas-prompt-regexp))

;; this has to be done in a hook. grumble grumble.
(add-hook 'inferior-sas-mode-hook 'sas--initialize)
#+end_src

* l'idee du nom du process:
** python.el
1. chaque buffer de commande =toto.py= par exemple peut avoir 1 seul buffer python dedicated
2. Il y a un buffer global possible
3. on stocke rien.
Pour recuperer le nom du process =python-shell-get-buffer=
   - On regarde ou on est puis on construit le nom du process dedicated via
     =python-shell-get-process-name=
   - On constuit le nom du process global via  =python-shell-get-process-name=
   - on regarde si  le process est running via =comint-check-proc= et si oui on prend le dedicated puis sinon le global et sinon ???

stocke dans la variable (globale ?) =python-shell--parent-buffer= et il est cnostruit par =python-shell-get-process-name= dedicated)
** ESS
=ess-get-process= permet de recuperer le nom du process qui est
a priori stocké dans ~ess-local-process-name~ variable locale et aussi dans
~ess-process-name-list~
* sas-mode
l'idee est de proposer un mode d'edition pour sas
** keymap
#+begin_src emacs-lisp
(defvar sasbis-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map "\C-c\C-r"   #'ess-eval-region)
;   (define-key map "\C-c\M-r"   #'ess-eval-region-and-go)
    (define-key map "\C-c\C-b"   #'ess-eval-buffer)
;   (define-key map "\C-c\M-b"   #'ess-eval-buffer-and-go)
    (define-key map (kbd "C-c C-<up>")   #'ess-eval-buffer-from-beg-to-here)
    (define-key map (kbd "C-c C-<down>") #'ess-eval-buffer-from-here-to-end)
    (define-key map "\C-c\C-p"   #'ess-eval-paragraph-and-step)
;   (define-key map "\C-c\M-p"   #'ess-eval-paragraph-and-go)
;   (define-key map "\C-\M-x"    #'ess-eval-region-or-function-or-paragraph)
    (define-key map "\C-c\C-n"   #'ess-eval-line-visibly-and-step)
    (define-key map "\C-c\C-j"   #'ess-eval-line)
    (define-key map [(control return)] #'ess-eval-region-or-line-visibly-and-step)
;   (define-key map "\C-c\M-j"   #'ess-eval-line-and-go)
    ;; FIXME: The next three can only work in S/R - mode
;   (define-key map "\C-c\C-l"   #'ess-load-file)
    ;;; Make an alias because C-c C-l is taken up by comint in inferiors
    (define-key map "\C-c\M-l"   #'ess-load-file)
    (define-key map "\C-c\C-v"   #'ess-display-help-on-object)
    (define-key map "\C-c\C-s"   #'ess-switch-process)
    (define-key map "\t"         #'ess-indent-or-complete)
    (define-key map "\C-c\C-q"   #'ess-quit)
   map)
  "Keymap for `sasbis-mode'.")
#+end_src
** les commandes d'envoi
dans ess-inf.el, l'idee est de les copier une par une puis de voir si elle reviennent toutes vers la meme commande basique qui sera a implementer en 2 methodes -> soumission en batch ou soumission en comint

** variables et definition du mode
#+begin_src emacs-lisp :tangle sas-mode.el
(defcustom ess-sas-tab-stop-list
  '(4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120)
  "List of tab stop positions used by `tab-to-tab-stop' in sas-mode."
  :type '(repeat integer)
  :group 'sasbis-mode)

(define-derived-mode sasbis-mode fundamental-mode "sas"
  "Major mode for editing SAS source. "
  :group 'sasbis-mode
  ;; (ess-setq-vars-local SAS-customize-alist)
  ;; (setq ess-local-customize-alist SAS-customize-alist)
  (setq-local sentence-end ";[\t\n */]*")
  (setq-local paragraph-start "^[ \t]*$")
  (setq-local paragraph-separate "^[ \t]*$")
  (setq-local paragraph-ignore-fill-prefix t)
  (setq-local adaptive-fill-mode nil)
  (setq-local indent-line-function #'sas-indent-line)
  (setq-local comment-start "/*")
  (setq-local comment-start-skip "/[*]")
  (setq-local comment-end "*/")
  (setq-local comment-end-skip "[*]/")
  (setq-local comment-column 40)
  ;;  (setq-local ess-local-process-name nil)
  (setq-local tab-stop-list ess-sas-tab-stop-list)
  (setq font-lock-defaults
        ;; KEYWORDS KEYWORDS-ONLY CASE-FOLD .....
        '(sasbis-mode-font-lock-defaults nil t)))
#+end_src

#+RESULTS:
: sasbis-mode

#+begin_src emacs-lisp :tangle sasbis-mode.el
(defvar sasbis-mode-font-lock-defaults
  (list
       ;; .log NOTE: messages
       (cons "^NOTE [0-9]+-[0-9]+: Line generated by the invoked macro"
             font-lock-comment-face)
       (cons "^NOTE: .*$"                          font-lock-comment-face)
       (cons "^      [^ @].*[.]$"                   font-lock-comment-face)
       (cons "^      [a-z].*[a-z][ ]?$"            font-lock-comment-face)
       (cons "^      Engine:[ ]+V.+$"              font-lock-comment-face)
       (cons "^      Physical Name:[ ]+.+$"        font-lock-comment-face)
       (cons "^      \\(cpu\\|real\\) time[ ]+[0-9].*$"
             font-lock-comment-face)
       (cons "^      decimal may be shifted by the"
             font-lock-comment-face)
       (cons "^NOTE: The infile "                  font-lock-comment-face)
       (cons "^NOTE: 1 record was read from the infile "
             font-lock-comment-face)
       (cons "^NOTE: [1-9][0-9]* records were read from the infile "
             font-lock-comment-face)
       (cons "^      Filename=.*,$"                font-lock-comment-face)
       (cons "^      File Name=.*,$"               font-lock-comment-face)
       (cons "^      File $"                       font-lock-comment-face)
       (cons "^      Name=.*,$"                    font-lock-comment-face)
       (cons "^      File List=("                  font-lock-comment-face)
       (cons "^      List=("                       font-lock-comment-face)
       (cons "^      Owner Name=.*,$"              font-lock-comment-face)
       (cons "^      Access Permission=.*,$"       font-lock-comment-face)
       (cons "^      Last Modified=.*,?$"          font-lock-comment-face)
       (cons "^      File Size (bytes)=[0-9]+$"    font-lock-comment-face)
       (cons "^      Pipe command="                font-lock-comment-face)
       (cons "^NOTE: The file "                    font-lock-comment-face)
       (cons "^NOTE: 1 record was written to the file "
             font-lock-comment-face)
       (cons "^NOTE: [1-9][0-9]* records were written to the file "
             font-lock-comment-face)
       (cons "^NOTE: PROC LOGISTIC is modeling the probability that"
             font-lock-comment-face)
       (cons "^NOTE: PROC GENMOD is modeling the probability that"
             font-lock-comment-face)
       (cons "^1[ ]+The SAS System.*$"             font-lock-comment-face)
       (cons "^\014.*$"                            font-lock-comment-face)
       (cons "[*][*][*] ANNOTATE macros are now available [*][*][*]"
             font-lock-comment-face)
       (cons "For further information on ANNOTATE macros, enter,"
             font-lock-comment-face)
       ;; (cons "^SAS/STAT 9.3_M1, SAS/ETS 9.3_M1, SAS/OR 9.3_M1"
       ;;       font-lock-comment-face)
       (cons "\\(or \\)?%HELPANO.*$"
             font-lock-comment-face)
       (cons "^Local Variables:$"                  font-lock-comment-face)
       (cons "^End:$"                              font-lock-comment-face)
       (cons "^MPRINT([_A-Z0-9]+)"                 font-lock-comment-face)

       ;; .log ERROR: messages
                                        ;     (cons "^ERROR\\( [0-9]+-[1-9][0-9][0-9]\\)?: .*$"
       (cons "^ERROR\\( [0-9]+-[0-9]+\\)?: .*$"
             font-lock-keyword-face)
                                        ;       ERROR:
       (cons "^       [^ @].*\\([.][ ]?[ ]?\\|[,a-z][ ]\\)$"
             font-lock-keyword-face)
                                        ;       ERROR #-###:
       (cons "^             [^ @].*\\([.][ ]?[ ]?\\|[,a-z][ ]\\)$"
             font-lock-keyword-face)
                                        ;       ERROR ##-###:
       (cons "^              [^ @].*\\([.][ ]?[ ]?\\|[,a-z][ ]\\)$"
             font-lock-keyword-face)
                                        ;       ERROR ###-###:
       (cons "^               [^ @].*\\([.][ ]?[ ]?\\|[,a-z][ ]\\)$"
             font-lock-keyword-face)
       (cons "^              a format name."       font-lock-keyword-face)
       (cons "^       where a numeric operand is required. The condition was: "
             font-lock-keyword-face)
       (cons "[ ][_]+$"                            font-lock-keyword-face)

       ;; .log WARNING: messages
                                        ;(cons "^WARNING\\( [0-9]+-[1-9][0-9][0-9]\\)?: .*$"
       (cons "^WARNING\\( [0-9]+-[0-9]+\\)?: .*$"
             font-lock-function-name-face)
                                        ;       WARNING:
       (cons "^         [^ @].*\\([.][ ]?[ ]?\\|[,a-z][ ]\\)$"
             font-lock-function-name-face)
                                        ;       WARNING #-###:
       (cons "^               [^ @].*\\([.][ ]?[ ]?\\|[,a-z][ ]\\)$"
             font-lock-function-name-face)
                                        ;       WARNING ##-###:
       (cons "^                [^ @].*\\([.][ ]?[ ]?\\|[,a-z][ ]\\)$"
             font-lock-function-name-face)
                                        ;       WARNING ###-###:
       (cons "^                 [^ @].*\\([.][ ]?[ ]?\\|[,a-z][ ]\\)$"
             font-lock-function-name-face)

       ;; SAS comments
       ;; /* */ style handled by grammar above
       (cons "\\(^[0-9]*\\|[:;!]\\)[ \t]*%?\\*[^;/][^;]*;"
             font-lock-comment-face)

                                        ; these over-rides need to come before the more general declarations
       (cons "\\<and("      font-lock-function-name-face)
       (cons "\\<data="     font-lock-keyword-face)
       (cons "\\<in:("      font-lock-function-name-face)
       (cons "\\<index("    font-lock-function-name-face)
       (cons "\\<input("    font-lock-function-name-face)
       (cons "\\<libname("  font-lock-function-name-face)
       (cons "\\<not("      font-lock-function-name-face)
       (cons "\\<or("       font-lock-function-name-face)
       (cons "\\<put("      font-lock-function-name-face)
       (cons "\\<sum("      font-lock-function-name-face)

                                        ; other idiosyncratic keywords
                                        ;(cons "key="      font-lock-keyword-face)
                                        ;(cons "/unique"   font-lock-keyword-face)

       ;; SAS execution blocks: DATA, %MACRO/%MEND, %DO/%END, etc.
       (cons (regexp-opt '(
                           "data" "start" "return" ;"proc"
                           "%macro" "%mend"
                           "%do" "%to" "%by" "%end"
                           "%goto" "%go to"
                           "%if" "%then" "%else"
                           "%global" "%inc" "%include" "%input" "%local" "%let" "%put" "%sysexec"
                           ) 'words) font-lock-constant-face)

       ;; SAS execution blocks that must be followed by a semi-colon
       (cons (concat "\\<"
                     (regexp-opt
                      '(
                        "run;" "quit;" "endsas;" "finish;"
                        "cards;" "cards4;" "datalines;" "datalines4;" "lines;" "lines4;"
                        )))
             font-lock-constant-face)

       ;; SAS statements that must be followed by a semi-colon
       (cons (concat "\\<"
                     (regexp-opt
                      '(
                        "end;" "list;" "lostcard;" "page;" "stop;" ;"return;"
                        )))
             font-lock-keyword-face)

       ;; SAS statements that must be followed by an equal sign
       (cons (concat "\\<"
                     (regexp-opt
                      '(
                        "compress=" "in=" "out=" "sortedby="
                        )))
             font-lock-keyword-face)

;;;    ;; SAS procedure names
       (cons (concat "\\<proc[ ]+"
                     (regexp-opt '(
                                   ;; SAS base and SAS/Graph
                                   "append"
                                   "calendar" "catalog" "chart" "cimport" "cport" "compare" "contents" "copy" "corr"
                                   "datasets" "dbcstab" "display"
                                   "explode" "export"
                                   "fcmp" "format" "forms" "freq" "fsbrowse" "fsedit" "fsletter" "fslist" "fsview"
                                   "ganno" "gchart" "gcontour" "gdevice" "geocode" "gfont" "gimport" "ginside"
                                   "gkeymap" "gmap" "goptions" "gplot" "gprint" "gproject" "greduce" "gremove"
                                   "greplay" "gslide" "gtestit" "g3d" "g3grid"
                                   "iml" "import" "insight"
                                   "mapimport" "means"
                                   "options"
                                   "plot" "pmenu" "print" "printto"
                                   "rank" "registry" "report"
                                   "setinit" "sgdesign" "sgmap"
                                   "sgpanel" "sgplot" "sgrender" "sgscatter" "sort" "sql" "standard" "summary"
                                   "tabulate" "template" "timeplot" "transpose" "trantab"
                                   "univariate"

                                   ;;SAS/Stat and SAS/ETS
                                   "aceclus" "anova" "arima" "autoreg"
                                   "bgenmod" "blifereg" "boxplot" "bphreg"
                                   "calis" "cancorr" "candisc" "catmod" "citibase" "cluster" "computab" "corresp" "countreg"
                                   "discrim" "distance"
                                   "entropy" "expand"
                                   "factor" "fastclus" "forecast"
                                   "gam" "gee" "genmod" "glimmix" "glm" "glmmod" "glmpower" "glmselect"
                                   "hpmixed"
                                   "inbreed"
                                   "kde" "krige2d"
                                   "lattice" "lifereg" "lifetest" "loess" "logistic"
                                   "mcmc" "mdc" "mds" "mi" "mianalyze" "mixed" "modeclus" "model" "mortgage" "multtest"
                                   "nested" "nlin" "nlmixed" "npar1way"
                                   "orthoreg"
                                   "panel" "pdlreg" "phreg" "plan" "plm" "pls" "power" "princomp" "prinqual" "probit"
                                   "qlim" "quantreg"
                                   "reg" "risk" "robustreg" "rsreg"
                                   "score" "seqdesign" "seqtest" "severity" "sim2d" "similarity" "simlin" "simnormal"
                                   "spectra" "statespace" "stdize" "stepdisc"
                                   "surveyfreq" "surveylogistic" "surveymeans" "surveyphreg" "surveyreg" "surveyselect" "syslin"
                                   "tcalis" "timeid" "timeseries" "tphreg" "tpspline" "transreg" "tree" "ttest"
                                   "ucm"
                                   "varclus" "varcomp" "variogram" "varmax"
                                   "x11" "x12"
                                   ) 'words)) font-lock-constant-face)

                                        ;       (cons (concat
                                        ;             "\\<"
                                        ;             "do[ \t]*" (regexp-opt '("over" "until" "while") t) "?"
                                        ;             "\\>")
                                        ;            font-lock-keyword-face)
                                        ;
       ;; SAS base and SAS/Graph statements
       (cons (concat ;"\\<"
              (regexp-opt
               '(
                 "do" "to" "by" "goto" ; "go"
                 "abort" "and" "array" "assess" "attrib"
                 "baseline" "bayes" "between" "bivar" "block" "bubble" "bubble2"
                 "change" "choro" "class" "contains" "contrast"
                 "delete" "display" "dm" "donut" "drop"
                 "else" "error" "exchange" "exclude"
                 "fcs" "file" "filename" "format" "freq"
                 "footnote" "footnote1" "footnote2" "footnote3" "footnote4" "footnote5"
                 "footnote6" "footnote7" "footnote8" "footnote9" "footnote10"
                 "goptions" "grid" ; "ge" "gt"
                 "hazardratio" "hbar" "hbar3d"
                 "id" "if" "index" "infile" "informat" "input" ; "is" rarely used, but common false pos.
                 "keep"
                 "label" "length" "libname" "like" "link" "lsmeans" ; "le" "lt"
                 "manova" "means" "merge" "missing" "model" "modify"
                 "not" "null" ; "ne" "note"
                 "ods" "options" "output" "otherwise" ; "or"
                 "pageby" "parms" "pie" "pie3d" "plot" "plot2" "prism" "put"
                 "random" "rename" "repeated" "retain"
                 "same" "save" "scatter" "select" "set" "skip" "star" "strata" "sum" "sumby" "surface"
                 "table" "tables" "test" "then" "time"
                 "title" "title1" "title2" "title3" "title4" "title5"
                 "title6" "title7" "title8" "title9" "title10"
                 "univar" "update"
                 "value" "var" "vbar" "vbar3d"
                 "weight" "where" "window" "with"
                                        ; "x"
                 ) 'words)) ;"\\>")
             font-lock-keyword-face)

       ;; SAS/GRAPH statements not handled above
       (cons (concat "\\<"
                     (regexp-opt
                      '("axis" "legend" "pattern" "symbol")) "\\([1-9][0-9]?\\)?"
                      "\\>")
             font-lock-keyword-face)

       ;; SAS functions and SAS macro functions
       (cons "%[a-z_][a-z_0-9]*[(;]"                  font-lock-function-name-face)
                                        ;(cons "\\<call[ \t]+[a-z]+("                   font-lock-function-name-face)

       (cons (concat ;"\\<"
              (regexp-opt
               '(
                 "abs" "arcos" "arsin" "atan"
                 "betainv" "byte"
                 "call execute" "call label" "call module" "call modulei"
                 "call poke" "call ranbin" "call rancau" "call ranexp"
                 "call rangam" "call rannor" "call ranpoi" "call rantbl"
                 "call rantri" "call ranuni" "call rxchange" "call rxfree"
                 "call rxsubstr" "call set" "call streaminit" "call symput" "call system"
                 "cdf" "ceil" "cinv" "collate" "compress" "convx" "convxp" "cos" "cosh" "css" "cv"
                 "daccdb" "daccdbsl" "daccsl" "daccsyd" "dacctab"
                 "depdb" "depdbsl" "depsl" "depsyd" "deptab"
                 "date" "datejul" "datepart" "datetime" "day" "dhms" "dif" "digamma" "dim"
                 "erf" "erfc" "exp"
                 "finv" "fipname" "fipnamel" "fipstate" "floor" "fuzz"
                 "gaminv" "gamma"
                 "hbound" "hms" "hour"
                 "in" "index" "indexc" "input" "int" "intck" "intnx" "intrr" "irr"
                 "juldate"
                 "kurtosis"
                 "lag" "lbound" "left" "length" "lgamma" "log" "log10" "log2"
                 "logcdf" "logpdf" "logsdf"
                 "max" "mdy" "mean" "min" "minute" "mod" "month" "mort"
                 "n" "netpv" "nmiss" "normal" "npv"
                 "ordinal"
                 "pdf"
                 "probbeta" "probbnml" "probchi" "probf" "probgam" "probhypr" "probit" "probnegb" "probnorm" "probt"
                 "poisson" "put"
                 "qtr" "quantile"
                 "rand" "range" "rank" "repeat" "reverse" "right" "round" "rxmatch" "rxparse"
                 "ranbin" "rancau" "ranexp" "rangam" "rannor" "ranpoi" "rantbl" "rantri" "ranuni"
                 "saving" "scan" "sdf" "second" "sign" "sin" "sinh" "sqrt" "squantile"
                 "std" "stderr" "stfips" "stname" "stnamel" "substr" "sum" "symget"
                 "tan" "tanh" "time" "timepart" "tinv" "today" "translate" "trigamma" "trim" "trunc"
                 "uniform" "until" "upcase" "uss"
                 "var" "verify"
                 "weekday" "when" "while"
                 "year" "yyq"
                 "zipfips" "zipname" "zipnamel" "zipstate"

;;;    ;; SAS/IML functions
                 "all" "allcomb" "allperm" "any" "apply" "armasim"
                 "bin" "blankstr" "block" "branks" "bspline" "btran" "byte"
                 "char" "choose" "col" "colvec" "concat" "contents" "convexit" "corr" "corr2cov"
                 "countmiss" "countn" "countunique" "cov" "cov2corr" "covlag" "cshape" "cusum"
                 "cuprod" "cv" "cvexhull"
                 "datasets" "design" "designf" "det" "diag" "dimension" "distance" "do" "duration"
                 "echelon" "eigval" "eigvec" "expmatrix" "expandgrid"
                 "fft" "fftc" "forward" "froot" "full"
                 "gasetup" "geomean" "ginv"
                 "hadamard" "half" "hankel" "harmean" "hdir" "hermite" "homogen"
                 "i" "ifft" "ifftc" "importtablefromr" "insert" "inv" "invupdt" "isempty" "isskipped"
                 "j" "jroot"
                 "kurtosis"
                 "lambertw" "listgetallnames" "listgetitem" "listgetname" "listgetsubitem" "listindex"
                 "listlen" "loc" "logabsdet"
                 "mad" "magic" "mahalanobis" "moduleic" "modulein"
                 "name" "ncol" "nrow" "ndx2sub" "nleng" "norm" "num"
                 "opscal" "orpol"
                 "parentname" "palette" "polyroot" "prod" "product" "pv"
                 "quartile"
                 "rancomb" "randdirichlet" "randfun" "randmultinomial" "randmvt" "randnormal" "randwishart"
                 "ranperk" "ranperm" "ranktie" "rates" "ratio" "remove" "repeat" "root" "row"
                 "rowcat" "rowcatc" "rowvec" "rsubstr"
                 "sample" "setdif" "shape" "shapecol" "skewness" "solve" "sparse" "splinev" "spot"
                 "sqrsym" "sqrvech" "ssq" "standard" "storage" "sub2ndx" "sweep" "symsqr"
                 "t" "tablecreate" "tablecreatefromdataset" "tablegetvardata" "tablegetvarformat"
                 "tablegetvarindex" "tablegetvarinformat" "tablegetvarlabel" "tablegetvarname"
                 "tablegetvartype" "tableisexistingvar" "tableisvarnumeric" "tfhilbert" "tfpwv"
                 "tfstft" "tfwindow" "toeplitz" "trace" "trisolv" "type"
                 "union" "unique" "uniqueby"
                 "value" "vecdiag" "vech"
                 "xmult" "xsect"
                 "yield"

;;;    ;; SAS functions introduced in Technical Report P-222
                 "airy"
                 "band" "blshift" "brshift" "bnot" "bor" "bxor"
                 "cnonct" "compbl"
                 "dairy" "dequote"
                 "fnonct"
                 "ibessel" "indexw" "inputc" "inputn"
                 "jbessel"
                 "lowcase"
                 "putc" "putn"
                 "quote"
                 "resolve"
                 "soundex" "sysprod"
                 "tnonct" "tranwrd" "trimn"

;;;    ;; SCL functions that are known to work with SAS macro function %sysfunc
                 "attrc" "attrn"
                 "cexist" "close"
                 "dclose" "dnum" "dopen" "dread"
                 "exist"
                 "fclose" "fetchobs" "fileexist" "finfo" "fopen" "fput" "fwrite"
                 "getoption" "getvarc" "getvarn"
                 "libname" "libref"
                 "open" "optgetn" "optsetn"
                 "pathname"
                 "sysmsg"
                 "varfmt" "varlabel" "varnum" "vartype"
                 ) 'words) ;"\\>"
              "("); "[ \t]*(")
             font-lock-function-name-face)
       )
     )
  ;; "Font Lock regexs for SAS."

#+end_src

*** tests
**** test de =make-process=
OK
#+begin_src emacs-lisp
(defun run-sas-direct ()
  "Run an inferior instance of `sas' inside Emacs."
  (interactive)
  (let* ((sas-program sas-cli-file-path))
    ;; pop to the "*sas*" buffer if the process is dead, the
    ;; buffer is missing or it's got the wrong mode.
    (make-process (list :name "sas" :buffer (generate-new-buffer "*sas*")
                        :command (list "/usr/local/bin/sas_u8" "-nodms" "-nonews" "-stdio"
                                       "-nofullstimer" "-nodate" "-nocenter"
                                       "-terminal" "-pagesize" "max"
                                       "-nosyntaxcheck")
                        :stderr (generate-new-buffer "*sas-errors*")))
    ))
#+end_src
#+begin_src emacs-lisp
(apply #'make-process (list :name "sas" :buffer (generate-new-buffer "*sas*")
                        :command (list "/usr/local/bin/sas_u8" "-nodms" "-nonews" "-stdio"
                            "-nofullstimer" "-nodate" "-nocenter"
                            "-terminal" "-pagesize" "max"
                            "-nosyntaxcheck")
                        :stderr (generate-new-buffer "*sas-errors*")))
#+end_src

#+RESULTS:
: #<process sas>

**** ouverture
#+begin_src emacs-lisp :results none
(run-sas)
#+end_src
#+begin_src emacs-lisp :results output
(list-processes)
(process-list)
(message "proc : %s" (comint-check-proc "*sas*"))
#+end_src

#+RESULTS:

#+begin_src emacs-lisp :results output
(run-sas-direct)
#+end_src
#+begin_src emacs-lisp
(make-process :name "sas" :buffer (generate-new-buffer "*sas*")
                        :command (list "/usr/local/bin/sas_u8" "-nodms" "-nonews" "-stdio"
                            "-nofullstimer" "-nodate" "-nocenter"
                            "-terminal" "-pagesize" "max"
                            "-nosyntaxcheck")
                        :stderr (generate-new-buffer "*sas-errors*"))
#+end_src

#+RESULTS:
: #<process sas>

**** envoi string: fermeture
#+begin_src emacs-lisp :results output
(comint-send-string "*sas*" "endsas;\n")
#+end_src

#+RESULTS:

#+begin_src emacs-lisp :results output
(process-send-string "sas" "endsas;\n")
#+end_src

#+RESULTS:

**** envoi d'une proc
#+begin_src emacs-lisp :results output
;(comint-send-string "*sas*" "proc setinit;\n run;\n")
(comint-send-string "*sas*" "data a; v=1; run; proc print data=a; run;\n")
#+end_src

#+RESULTS:

#+begin_src emacs-lisp :results output
;(process-send-string (get-process "*sas*")  "proc setinit;\n run;\n")
(process-send-string "sas"  "data a; v=1; run; proc print data=a; run;\n")
(while (accept-process-output (get-process "*sas*") ))
(while (accept-process-output (get-process "*sas errors*")))
#+end_src

#+RESULTS:

**** test buffer vivant
#+begin_src emacs-lisp
(require 'ob-comint)
(message "yes %s" (org-babel-comint-buffer-livep "*sas*"))
#+end_src

#+RESULTS:
: yes nil

**** test vivant
#+begin_src emacs-lisp
(require 'ob-comint)
(message "yes %s" (get-buffer-process  (get-buffer "*sas*")))
#+end_src

#+RESULTS:
: yes t

**** test envoi via ob-comint
#+begin_src emacs-lisp
(require 'ob-comint)
;; (org-babel-comint-in-buffer (get-buffer "*sas*") "proc setinit;\n run;\n")
(with-current-buffer
 (switch-to-buffer "*sas*" )
 (org-babel-comint-input-command "*sas*" "proc setinit;\n run;\n"))
#+end_src

#+RESULTS:
: proc setinit;
:  run;
**** test envoi via ob-commint
#+begin_src emacs-lisp
(let* ((org-babel-sas-eoe-indicator
        "data eoe_org_data;\n nbabelvareoe=1;\nrun;\nproc print data=eoe_org_data;\nrun;\n")
       (full-body (concat "proc setinit; run;\n" org-babel-sas-eoe-indicator)))
  (with-current-buffer
      (switch-to-buffer "*sas*")
    (org-babel-comint-input-command "*sas*" full-body)))
#+end_src
* async
** ipython
https://github.com/gregsexton/ob-ipython/blob/master/ob-ipython.el
** ob-async
https://github.com/astahlman/ob-async
base sur
https://github.com/jwiegley/emacs-async

* ob-sas.el
** header
 #+BEGIN_SRC elisp :tangle ob-sas.el
 ;;; ob-sas.el --- org-babel functions for sas code evaluation

 ;; Copyright (C) 2019 P.A. Cornillon
 ;; Author: P.A. Cornillon
 ;;      G. Jay Kerns
 ;;      Eric Schulte
 ;;      Dan Davison


 ;; This file is not part of GNU Emacs.

 ;; This program is free software; you can redistribute it and/or modify
 ;; it under the terms of the GNU General Public License as published by
 ;; the Free Software Foundation; either version 3, or (at your option)
 ;; any later version.
 ;;
 ;; This program is distributed in the hope that it will be useful,
 ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
 ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ;; GNU General Public License for more details.
 ;;
 ;; You should have received a copy of the GNU General Public License
 ;; along with GNU Emacs; see the file COPYING.  If not, write to the
 ;; Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 ;; Boston, MA 02110-1301, USA.

 ;;; Commentary:

 ;; The file provides Org-Babel support for evaluating sas code.  It is
 ;; basically the adaptation of
 ;; ob-R.el by E. Schulte which results of find-and-replace "julia" by "sas" in
 ;; ob-julia.el by G. Jay Kerns.
 ;; see
 ;; https://github.com/Pierre-Andre/Org-Babel-sas
 ;;; Requirements:
 ;; Sas: http://sas.com
 ;; ESS: http://ess.r-project.org (only for session in unix/linux)
 #+END_SRC
** include
 #+BEGIN_SRC  elisp :tangle ob-sas.el
 ;;; Code:
 (require 'ob)
 (require 'cl-lib)

 (declare-function orgtbl-to-csv "org-table" (table params))
 (declare-function sas "ext:ess-sas" (&optional start-args))
 (declare-function inferior-ess-send-string "ext:ess-inf" ())
 (declare-function ess-make-buffer-current "ext:ess-inf" ())
 (declare-function ess-eval-buffer "ext:ess-inf" (vis))
 (declare-function org-number-sequence "org-compat" (from &optional to inc))
 #+END_SRC
** Custom Variables
 #+BEGIN_SRC   elisp :tangle ob-sas.el
 ;;;;;;;;;;;;;;;; could be useful to increase or decrease timeout ....
 (defcustom org-babel-sas-timeout 1000
   "Timeout (in sec) used when waiting output from a submitted src block (to sas) with argument :session."
   :group 'org-babel
   :type 'integer)
 ;;;;;;;;;;;;;;;; could be useful to tweak printing page size
 (defcustom org-babel-sas-print-options "options formdlim='' pagesize=max nocenter nodate;\n"
   "general options used to have the maximum page size"
   :group 'org-babel
   :type 'string)

 ;;;;;;;;;;;;;;;; where is SAS (for :session "none" or :session
 (defcustom org-babel-sas-command "/usr/local/bin/sas_u8"
 ;  inferior-SAS-program-name
   "Command name to use for executing sas code."
   :group 'org-babel
   :type 'string)
 ;;;;;;;;;;;;;;; command line option to be used with SAS (for :session "none")
 (defcustom org-babel-sas-command-options
   "-formdlim='' -pagesize=max -nonumber -nodate -nocenter -nonews -nodms"
   "Options for sas batch"
   :group 'org-babel
   :type 'string)

 ;;;;;;;;;;;;;;; windows SAS or not
 (defcustom org-babel-sas-windows
   nil
   "SAS on windows (non nil)  or not (nil)"
   :group 'org-babel
   :type 'boolean)
 ;;;;;;;;;;;;;;; real session or not (user library)
 (defcustom org-babel-sas-realsession
   nil
   "is the :session will use ESS to make a real session (non nil, unix only)
    or use a user library (nil)"
   :group 'org-babel
   :type 'boolean)
 ;;;;;;;;;;;;;;; custom log file name (for :session "none")
 (defcustom org-babel-sas-logfile-name
   nil
   "Optionnal log-file name for :session none"
   :group 'org-babel
   :type 'string)
 #+END_SRC
** Utilities
 #+BEGIN_SRC   elisp :tangle ob-sas.el
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;; global alist to take care of previous commands done in session
 (defvar org-babel-sas-lepoint (list (cons "sessionSAS" 1)))
 ;; small sas program sent to sas after the actual sas chunk
 ;; this define the end signal
 (defvar org-babel-sas-eoe-indicator "data eoe_org_data;\n nbabelvareoe=1;\nrun;\nOPTIONS NODATE NONUMBER;\nTITLE1;\nTITLE2;\nproc print data=eoe_org_data;\nrun;")
 ;; output of the corresponding small program
 ;; when seen it means that all the chunk is done
 (defvar org-babel-sas-eoe-output "Obs.    nbabelvareoe[ \n]+1[ ]+1")
 ;; cursor to be trimmed
 (defvar org-babel-sas-boe-output "$ tty\n/dev/pts/[0-9]+\n\\$")
 ;; header stuff
 (defconst org-babel-header-args:sas
   '((hsize		 . :any)
     (vsize		 . :any)
     (xpixels		 . :any)
     (ypixels		 . :any)
     (border		 . :any)
     (width		 . :any)
     (height		 . :any)
     (sastab		 . :any)
     (results             . ((file list vector table scalar verbatim)
			     (raw org html latex code pp wrap)
			     (replace silent append prepend)
			     (output value graphics odsgraphics log))))
   "sas-specific header arguments.")

 (add-to-list 'org-babel-tangle-lang-exts '("sas" . "sas"))

 ;; session using ESS is the way to go, so make that the default
 (defvar org-babel-default-header-args:sas '((:results . "output") (:session . nil)))

 ;; from unix to windows path (ie change / to \)
 (defun org-babel-sas-path-windows (s)
   "replace / by \\"
    (replace-regexp-in-string "/" "\\\\" s))
 ;; trim white space and garbage
 (defun org-babel-sas-trim-white (s)
   "replace S by empty string if S is whitespace/tab/CR only"
   (if (string-match "\\`[ \t\n\r]+\\'" s)
       (replace-match "" t t s)
     s))
 (defun org-babel-sas-trim-doubleline (s)
   "replace elo eol by eol"
   (if (string-match "\n\n" s)
       (replace-match "\n" t t s)
     s))
 (defun org-babel-sas-trim-end (s)
   "replace eol + white by eol"
   (if (string-match "\n[ ]+\\'" s)
       (replace-match "\n" t t s)
     s))
 (defun org-babel-sas-trim-begin (s)
   "replace eol by empty string"
   (if (string-match "\\`\n" s)
       (replace-match "" t t s)
     s))
 #+END_SRC
** Main function
 #+BEGIN_SRC   elisp :tangle ob-sas.el
 (defun org-babel-execute:sas (body params)
   "Execute a block of sas code.
 This function is called by `org-babel-execute-src-block'."
   (save-excursion
     (let* ((result-params (cdr (assq :result-params params)))
	    (result-type (cdr (assq :result-type params)))
	    (session (org-babel-sas-initiate-session
		      (cdr (assq :session params)) params))
	   (graphics-file (org-babel-sas-graphical-output-file params))
	   (graphics-type (or (member "odsgraphics" (cdr (assq :result-params params))) (member "graphics" (cdr (assq :result-params params)))))
	   (sastab-value (if (string-equal result-type "value")
			     (cdr (assq :sastab params))
			   nil))
	   (sastab-tmp-file (if (string-equal result-type "value")
			     (org-babel-temp-file "SASexport-")
			     nil))
	   (full-body (org-babel-expand-body:sas body params graphics-file graphics-type sastab-value sastab-tmp-file))
	   (result
	    (org-babel-sas-evaluate
	     session full-body result-type result-params sastab-tmp-file)))
       (if graphics-file nil result))))
 #+END_SRC
	  (blob (message "avant init session\n - realsession: %s \n - session: %s" org-babel-sas-realsession (cdr (assq :session params)) ))
	  (blob (message "apres init session\n - realsession: %s \n - session: %s" org-babel-sas-realsession session))
    	   (message ": %s" full-body)

** Session
- If session is "none" -> return nil (no session)
- If :session (ie :session key exists but its value is empty)
  - if org-babel-sas-realsession=t -> start session via ESS
  - if org-babel-sas-realsession=nil -> return temp directory path
- If value of :session key is a buffer or a string equal to "*SAS*"
  -> session is already active nothig to do, return key value of :session
  + one must verify that org-babel-sas-realsession=t (if not error)
- If value of :session key is a string (path of a directory) and org-babel-sas-realsession=nil
  -> return path

  Another if/else (equivalent)
  - If session is "none" -> return nil (no session)
  - Else
    - if org-babel-sas-realsession=nil
      - if :session key is a string (path of a directory) -> return path
      - else return temp directory path
    - else Usual start session (two cases)


 #+BEGIN_SRC  elisp :tangle ob-sas.el
   (defvar ess-ask-for-ess-directory) ; dynamically scoped

(defun org-babel-sas-initiate-session (session params)
  "If there is not a current sas process then create one
  (if realsession) or give as a string the library directory
  (if not realsession)"
  (if (string= session "none") "none"
    (if (null org-babel-sas-realsession)
        (if (stringp session) session
          org-babel-temporary-directory)
      (let ((session (or session "*SAS*"))
            (ess-ask-for-ess-directory
             (and (and (boundp 'ess-ask-for-ess-directory) ess-ask-for-ess-directory)
                  (not (cdr (assq :dir params))))))
        (if (org-babel-comint-buffer-livep session)
            session
          (save-window-excursion
            (require 'ess) (SAS)
            (rename-buffer
             (if (bufferp session)
                 (buffer-name session)
               (if (stringp session)
                   session
                 (buffer-name))))
            (add-to-list 'org-babel-sas-lepoint
                         (cons (concat "session-"
                                       (if (bufferp session)
                                           (buffer-name session)
                                         (if (stringp session)
                                             session
                                           (buffer-name)))) 1))
            (current-buffer)))))))
 #+END_SRC
  (message "if (null org-babel-sas-realsession) %s"(null org-babel-sas-realsession))

** Graphics
*** file name from graphics or odsgraphics parameter
 #+BEGIN_SRC elisp :tangle ob-sas.el
 (defun org-babel-sas-graphical-output-file (params)
   "Name of file to which sas should send graphical output."
   (and (or (member "graphics" (cdr (assq :result-params params)))
	    (member "odsgraphics" (cdr (assq :result-params params))))
	(cdr (assq :file params))))
 #+END_SRC
*** graphics devices association list
 #+BEGIN_SRC elisp :tangle ob-sas.el
 (defvar org-babel-sas-graphics-devices
   '((:bmp "bmp")
     (:emf "emf")
     (:tiff "tiff")
     (:png "png")
     (:png300 "png300")
     (:svg "svg")
     (:pdf "pdf")
     (:ps "pscolor")
     (:postscript "pscolor"))
   "An alist mapping graphics file types to SAS devices.

 Each member of this list is a list with three members:
 1. the file extension of the graphics file, as an elisp :keyword
 2. the SAS device function to call to generate such a file")

 ;; we need the following twolines with sas/graph :graphics
 ;; example of svg device
 ;; filename sortie "toto.svg";
 ;; goptions  device=svg gsfname=sortie
 ;; or this line with ODS graphics :odsgraphics
 ;; ods graphics on /  imagefmt=png imagename="barplot" border=off width=10cm;
 #+END_SRC
*** graphic export command
 construction of the sas program to export graphics file
 #+BEGIN_SRC elisp :tangle ob-sas.el
 (defun org-babel-sas-construct-graphics-device-call (out-file graphics-type params)
   "Construct the string for choosing device and saving graphic file"
   (let* ((allowed-args '(:hsize :vsize :xpixels :ypixels :border :width :height))
	  (device (file-name-extension out-file))
	  (device-info (or (assq (intern (concat ":" device))
				 org-babel-sas-graphics-devices)
                           (assq :png org-babel-sas-graphics-devices)))
	  (extra-args (cdr (assq :SAS-dev-args params))) filearg args)
     (setq device (nth 1 device-info))
     (setq args (mapconcat
		 (lambda (pair)
		   (if (member (car pair) allowed-args)
		       (format " %s=%S"
			       (substring (symbol-name (car pair)) 1)
			       (cdr pair)) ""))
		 params ""))
     (if (string-equal (car graphics-type) "odsgraphics")
	 (format "ods graphics on / imagename=\"%s\" imagefmt=%s %s;\n"
		 (file-name-sans-extension out-file) device args
		 (if extra-args " " "") (or extra-args ""))
       (format "filename outfob \"%s\";\ngoptions  device=%s gsfname= outfob %s;\n"
	     out-file device args
	     (if extra-args " " "") (or extra-args "")))))
 #+END_SRC
** Expanded body
 include in the SAS chunk options, graphical command to export graphics and proc export in case of :value result
*** function to make the full-body
 Print option + graphics command + export command if needed (when :results value)
 #+BEGIN_SRC elisp :tangle ob-sas.el
 (defun org-babel-expand-body:sas (body params &optional graphics-file graphics-type sastab-value sastab-tmp-file)
   "Expand BODY according to PARAMS, return the expanded body."
   (let ((graphics-file
	  (or graphics-file
	      (org-babel-sas-graphical-output-file params)))
	 (graphics-type
	  (or graphics-type
	      (or (member "odsgraphics" (cdr (assq :result-params params)))
		  (member "graphics" (cdr (assq :result-params params)))))))
     (concat org-babel-sas-print-options
      (if graphics-file
	    (org-babel-sas-construct-graphics-device-call
	     graphics-file graphics-type params)
	"")
      body
      (if graphics-file
		     (if (string-equal (car graphics-type) "odsgraphics")
			 "quit;\nods graphics off;\n"
		       "quit;\n"))
      (if sastab-value
	  (org-babel-sas-construct-export-call sastab-value
					       (if org-babel-sas-windows (org-babel-sas-path-windows sastab-tmp-file) sastab-tmp-file))
	""))))
 #+END_SRC
*** Export for :results value
 A simple proc export in tab separated file (to be re-imported later
 and used as a value result)
 #+BEGIN_SRC elisp :tangle ob-sas.el
 (defun org-babel-sas-construct-export-call (sastab-value sastab-tmp-file)
   (let ((tmp-file (org-babel-temp-file "SAS-")))
     (concat "proc export data=" sastab-value "\n outfile='" sastab-tmp-file
      "'\n dbms=tab replace;\nrun;")))
 #+END_SRC
** Evaluation of the full-body
*** main function of evaluation
 The evaluation process is seprated in two cases: external subprocess
 or session (unixes only, with ess)
 #+BEGIN_SRC elisp :tangle ob-sas.el
 (defun org-babel-sas-evaluate
   (session body result-type result-params sastab-tmp-file)
   "Evaluate sas code in BODY."
   (if (and (string-or-null-p session) (not (string= session "*SAS*")))
       (org-babel-sas-evaluate-external-process
	body result-type result-params sastab-tmp-file session)
     (org-babel-sas-evaluate-session
      session body result-type result-params sastab-tmp-file)))
 #+END_SRC
*** evaluation in an external process
 All evaluation case except real session with ess under unixes.
 #+BEGIN_SRC elisp :tangle ob-sas.el
	  (defun org-babel-sas-evaluate-external-process
	    (body result-type result-params sastab-tmp-file session)
	    "Evaluate BODY in external sas process.
	  If RESULT-TYPE equals 'output then return standard output as a
	  string.  If RESULT-TYPE equals 'value then return the value of the
	  :sastab SAS table, as elisp."
	    (if (car (member "log" result-params))
	       ;; log
	       (let ((tmp-file (org-babel-temp-file "SAS-")))
		     ;;((tmp-file "sas-file4677846547.sas")
		 ;;(directory-sas ""))
		 (with-current-buffer
		     (switch-to-buffer (get-buffer-create (concat tmp-file ".sas")))
		   (set-visited-file-name (concat tmp-file ".sas"))
		   (insert body)
		   (save-buffer 0))
		 (shell-command (if org-babel-sas-windows
				    (if (string= session "none")
					(format "%s -SYSIN %s -NOTERMINAL NOSPLASH -NOSTATUSWIN -NOICON -PRINT %s -LOG %s"
					org-babel-sas-command
					(concat tmp-file ".sas")
					(concat tmp-file ".lst")
					(if org-babel-sas-logfile-name
					    org-babel-sas-logfile-name
					  (concat tmp-file ".log")))
					(format "%s -USER %s -SYSIN %s -NOTERMINAL NOSPLASH -NOSTATUSWIN -NOICON -PRINT %s -LOG %s"
					org-babel-sas-command session
					(concat tmp-file ".sas")
					(concat tmp-file ".lst")
					(if org-babel-sas-logfile-name
					    org-babel-sas-logfile-name
					  (concat tmp-file ".log"))))
				  (if (string= session "none")
				    (format "%s %s -log %s -print %s %s"
					org-babel-sas-command org-babel-sas-command-options
					(if org-babel-sas-logfile-name
					    org-babel-sas-logfile-name
					  (concat tmp-file ".log"))
					(concat tmp-file ".lst")
					(concat tmp-file ".sas"))
				    (format "%s -user %s %s -log %s -print %s %s"
					org-babel-sas-command session org-babel-sas-command-options
					(if org-babel-sas-logfile-name
					    org-babel-sas-logfile-name
					  (concat tmp-file ".log"))
					(concat tmp-file ".lst")
					(concat tmp-file ".sas")))) nil nil)
		 (kill-buffer (file-name-nondirectory (concat tmp-file ".sas")))
		 (delete-file (concat tmp-file ".sas"))
		 (if (file-readable-p (if org-babel-sas-logfile-name
					  org-babel-sas-logfile-name
					  (concat tmp-file ".log")))
		     (progn
		       (with-current-buffer
			   (switch-to-buffer (find-file-noselect (if org-babel-sas-logfile-name
					    org-babel-sas-logfile-name
					    (concat tmp-file ".log"))))
			 (beginning-of-buffer)
			 (setq body (buffer-string)))
		       (kill-buffer (file-name-nondirectory (if org-babel-sas-logfile-name
					    org-babel-sas-logfile-name
					    (concat tmp-file ".log"))))
		       (delete-file  (if org-babel-sas-logfile-name
					    org-babel-sas-logfile-name
					    (concat tmp-file ".log")))
		       body)
	 "no log file ??"))
	    (cl-case result-type
	      (value
	       ;; org-babel-eval does pass external argument...
	       (let ((tmp-file (org-babel-temp-file "SAS-")))
		     ;;((tmp-file "sas-file4677846547.sas")
		 ;;(directory-sas ""))
		 (with-current-buffer
		     (switch-to-buffer (get-buffer-create (concat tmp-file ".sas")))
		   (set-visited-file-name (concat tmp-file ".sas"))
		   (insert body)
		   (save-buffer 0))
		 (shell-command (if org-babel-sas-windows
				    (if (string= session "none")
					(format "%s -SYSIN %s -NOTERMINAL NOSPLASH -NOSTATUSWIN -NOICON -PRINT %s -LOG %s"
					org-babel-sas-command
					(concat tmp-file ".sas")
					(concat tmp-file ".lst")
					(if org-babel-sas-logfile-name
					    org-babel-sas-logfile-name
					  (concat tmp-file ".log")))
				      (format "%s -USER %s -SYSIN %s -NOTERMINAL NOSPLASH -NOSTATUSWIN -NOICON -PRINT %s -LOG %s"
					org-babel-sas-command session
					(concat tmp-file ".sas")
					(concat tmp-file ".lst")
					(if org-babel-sas-logfile-name
					    org-babel-sas-logfile-name
					  (concat tmp-file ".log"))))
				  (if (string= session "none")
				      (format "%s %s -log %s -print %s %s"
					org-babel-sas-command org-babel-sas-command-options
					(if org-babel-sas-logfile-name
					    org-babel-sas-logfile-name
					  (concat tmp-file ".log"))
					(concat tmp-file ".lst")
					(concat tmp-file ".sas"))
				    (format "%s -user %s %s -log %s -print %s %s"
					org-babel-sas-command session org-babel-sas-command-options
					(if org-babel-sas-logfile-name
					    org-babel-sas-logfile-name
					  (concat tmp-file ".log"))
					(concat tmp-file ".lst")
					(concat tmp-file ".sas")))) nil nil)
		 (kill-buffer (file-name-nondirectory (concat tmp-file ".sas")))
		 (delete-file (concat tmp-file ".sas"))
		 (if (file-readable-p sastab-tmp-file)
		     (org-babel-result-cond result-params
		       (org-babel-chomp
			(with-current-buffer (find-file-noselect sastab-tmp-file)
			  (buffer-string))
			"\n")
		       (org-babel-import-elisp-from-file sastab-tmp-file '(16)))
		   (progn
		     (if (get-buffer (if org-babel-sas-logfile-name
					    org-babel-sas-logfile-name
					  (concat tmp-file ".log")))
			 (with-current-buffer (get-buffer  (if org-babel-sas-logfile-name
							       org-babel-sas-logfile-name
							     (concat tmp-file ".log")))
			   (revert-buffer :ignore-auto :noconfirm :preserve-modes))
		       (save-window-excursion (pop-to-buffer-same-window (find-file-noselect (if org-babel-sas-logfile-name
							       org-babel-sas-logfile-name
							     (concat tmp-file ".log"))))))
		     (format "Errors, please see [[file://%s][log file]] (in Buffer list)" (if org-babel-sas-logfile-name
							       org-babel-sas-logfile-name
							     (concat tmp-file ".log")))))))
	      (output
	       ;; org-babel-eval does pass external argument...
	       (let ((tmp-file (org-babel-temp-file "SAS-")))
		     ;;((tmp-file "sas-file4677846547.sas")
		 ;;(directory-sas ""))
		 (with-current-buffer
		     (switch-to-buffer (get-buffer-create (concat tmp-file ".sas")))
		   (set-visited-file-name (concat tmp-file ".sas"))
		   (insert body)
		   (save-buffer 0))
		 (shell-command (if org-babel-sas-windows
				    (if (string= session "none")
					(format "%s -SYSIN %s -NOTERMINAL NOSPLASH -NOSTATUSWIN -NOICON -PRINT %s -LOG %s"
					org-babel-sas-command
					(concat tmp-file ".sas")
					(concat tmp-file ".lst")
					(if org-babel-sas-logfile-name
					    org-babel-sas-logfile-name
					  (concat tmp-file ".log")))
					(format "%s -USER %s -SYSIN %s -NOTERMINAL NOSPLASH -NOSTATUSWIN -NOICON -PRINT %s -LOG %s"
					org-babel-sas-command session
					(concat tmp-file ".sas")
					(concat tmp-file ".lst")
					(if org-babel-sas-logfile-name
					    org-babel-sas-logfile-name
					  (concat tmp-file ".log"))))
				  (if (string= session "none")
				    (format "%s %s -log %s -print %s %s"
					org-babel-sas-command org-babel-sas-command-options
					(if org-babel-sas-logfile-name
					    org-babel-sas-logfile-name
					  (concat tmp-file ".log"))
					(concat tmp-file ".lst")
					(concat tmp-file ".sas"))
				    (format "%s -user %s %s -log %s -print %s %s"
					org-babel-sas-command session org-babel-sas-command-options
					(if org-babel-sas-logfile-name
					    org-babel-sas-logfile-name
					  (concat tmp-file ".log"))
					(concat tmp-file ".lst")
					(concat tmp-file ".sas")))) nil nil)
		  (message "SAS log file is: %s" (if org-babel-sas-logfile-name
					    org-babel-sas-logfile-name
					  (concat tmp-file ".log")))
		 (kill-buffer (file-name-nondirectory (concat tmp-file ".sas")))
		 (delete-file (concat tmp-file ".sas"))
		   (if (file-readable-p (concat tmp-file ".lst"))
		     (progn
		       (with-current-buffer
			   (switch-to-buffer (find-file-noselect (concat tmp-file ".lst")))
			 (beginning-of-buffer)
			 (setq body (buffer-string)))
			(kill-buffer (file-name-nondirectory (concat tmp-file ".lst")))
		       (delete-file  (concat tmp-file ".lst"))
		       body)
		   (progn
		     (if (get-buffer (if org-babel-sas-logfile-name
					    org-babel-sas-logfile-name
					  (concat tmp-file ".log")))
			 (with-current-buffer (get-buffer  (if org-babel-sas-logfile-name
							       org-babel-sas-logfile-name
							     (concat tmp-file ".log")))
			   (revert-buffer :ignore-auto :noconfirm :preserve-modes))
		       (save-window-excursion (pop-to-buffer-same-window (find-file-noselect (if org-babel-sas-logfile-name
							       org-babel-sas-logfile-name
							     (concat tmp-file ".log"))))))
		     (format "Errors, please see [[file://%s][log file]] (in Buffer list)" (if org-babel-sas-logfile-name
							       org-babel-sas-logfile-name
							     (concat tmp-file ".log"))))))))))

 #+END_SRC
	(message "le programme est %s" body)
	(message "le fichier export est %s" sastab-tmp-file)
   (message "external process: evaluation la session est %s" session)

*** evaluation in an ess session
 Using ess, SAS commands can be sent to sas (without closing it). This
 function submits the full-body and get results or output
 #+BEGIN_SRC elisp :tangle ob-sas.el
 (defun org-babel-sas-evaluate-session
     (session body result-type result-params sastab-tmp-file)
   "Evaluate BODY in SESSION.
 If RESULT-TYPE equals 'output then return standard output as a
 string.  If RESULT-TYPE equals 'value then return the value of the
 last statement in BODY, as elisp."
   (cl-case result-type
     (value
      ;;     (let* ((allowed-args '(:sastab))
      (let ((org-babel-sas-ess-process-name  (process-name (get-buffer-process session))))
       (with-temp-buffer
	 (insert body)
	 (let ((ess-local-process-name
		(process-name (get-buffer-process session)))
	       (ess-eval-visibly-p nil))
	   (ess-eval-buffer nil)))
       (ess-send-string (get-process org-babel-sas-ess-process-name) org-babel-sas-eoe-indicator)
       ;;    excursion for cut/paste results from output buffer
       ;;   as output buffer is not the same as session buffer
       ;; org-babel-comint-with-output cannot be used
       (save-excursion
      	 (set-buffer (format "*%s.lst*" org-babel-sas-ess-process-name))
      	 (let* ((a 0) (b 0) (ancienpoint (cdr (assoc (concat "session-" (if (stringp session) session (buffer-name session))) org-babel-sas-lepoint))))
      	  (while (< a org-babel-sas-timeout)
      	    (setq b a)
      	    (goto-char (cdr (assoc (concat "session-" (if (stringp session) session (buffer-name session))) org-babel-sas-lepoint)))
      	    (setq a (re-search-forward org-babel-sas-eoe-output nil t))
      	    (if a
      		(progn (setq a org-babel-sas-timeout)
      	 	       (goto-char (cdr (assoc (concat "session-" (if (stringp session) session (buffer-name session))) org-babel-sas-lepoint)))
      	 	       (setq ancienpoint (cdr (assoc (concat "session-" (if (stringp session) session (buffer-name session))) org-babel-sas-lepoint)))
		       ;; well well, this is embarassing but
		       ;; as there's not history like in comint
		       ;; the last point is saved in this global
		       ;; alist variable (that will be used the
		       ;; next time)
      	 	       (setf (cdr (assoc (concat "session-" (if (stringp session) session (buffer-name session))) org-babel-sas-lepoint)) (point-max)))
      	      (setq a (+ b 1)))
      	    (sit-for 0.01)))))
       ;; get export value from sastab-tmp-file
       (org-babel-result-cond result-params
	 (org-babel-chomp
	  (with-current-buffer (find-file-noselect sastab-tmp-file)
	    (buffer-string)
	    )
	  "\n")
	 (org-babel-import-elisp-from-file sastab-tmp-file '(16))))
     (output
      ;; submit body through a temp buffer (in order to not go
      ;; beyond the limit of 500 bytes)
      ;; see
      ;; https://stat.ethz.ch/pipermail/ess-help/2015-April/010518.html
     (let ((org-babel-sas-ess-process-name  (process-name (get-buffer-process session))))
       (with-temp-buffer
	 (insert body)
	 (let ((ess-local-process-name
		(process-name (get-buffer-process session)))
	       (ess-eval-visibly-p nil))
	   (ess-eval-buffer nil)))
       (ess-send-string (get-process org-babel-sas-ess-process-name) org-babel-sas-eoe-indicator)
       ;;    excursion for cut/paste results from output buffer
       ;;   as output buffer is not the same as session buffer
       ;; org-babel-comint-with-output cannot be used
       (save-excursion
      	 (set-buffer (format "*%s.lst*" org-babel-sas-ess-process-name))
      	 (let* ((a 0) (b 0) (ancienpoint (cdr (assoc (concat "session-" (if (stringp session) session (buffer-name session))) org-babel-sas-lepoint))))
      	  (while (< a org-babel-sas-timeout)
      	    (setq b a)
      	    (goto-char (cdr (assoc (concat "session-" (if (stringp session) session (buffer-name session))) org-babel-sas-lepoint)))
      	    (setq a (re-search-forward org-babel-sas-eoe-output nil t))
      	    (if a
      		(progn (setq a org-babel-sas-timeout)
      	 	       (goto-char (cdr (assoc (concat "session-" (if (stringp session) session (buffer-name session))) org-babel-sas-lepoint)))
      	 	       (setq ancienpoint (cdr (assoc (concat "session-" (if (stringp session) session (buffer-name session))) org-babel-sas-lepoint)))
		       ;; well well, this is embarassing but
		       ;; as there's not history like in comint
		       ;; the last point is saved in this global
		       ;; alist variable (that will be used the
		       ;; next time)
      	 	       (setf (cdr (assoc (concat "session-" (if (stringp session) session (buffer-name session))) org-babel-sas-lepoint)) (point-max)))
      	      (setq a (+ b 1)))
      	    (sit-for 0.01))
       	  (org-babel-chomp (org-babel-sas-trim-end (org-babel-sas-trim-begin (org-babel-sas-trim-doubleline (org-babel-sas-trim-white (replace-regexp-in-string (concat "\\(\f\\)\\|\\(" org-babel-sas-boe-output "\\)\\|\\(" org-babel-sas-eoe-output "\\)") "" (buffer-substring ancienpoint (cdr (assoc (concat "session-" (if (stringp session) session (buffer-name session))) org-babel-sas-lepoint)))))))))))))))
 #+END_SRC
** end of file
 #+BEGIN_SRC elisp :tangle ob-sas.el
 (provide 'ob-sas)

 ;;; ob-sas.el ends here
 #+END_SRC
** Old stuff
 #+BEGIN_SRC elisp
 ;;;;;;;;;;;;;;;;;;; two functions not used (at the moment ?)
 (defun org-babel-sas-associate-session (session)
   "Associate sas code buffer with a sas session.
 Make SESSION be the inferior ESS process associated with the
 current code buffer."
   (setq ess-local-process-name
	 (process-name (get-buffer-process session)))
   (ess-make-buffer-current))

 (defun org-babel-load-session:sas (session body params)
   "Load BODY into SESSION."
   (save-window-excursion
     (let ((buffer (org-babel-prep-session:sas session params)))
       (with-current-buffer buffer
         (goto-char (process-mark (get-buffer-process (current-buffer))))
         (insert (org-babel-chomp body)))
       buffer)))
 ;;;;;;;;;;;;;;;;;;; end of not used
 #+END_SRC

* dot Emacs
#+BEGIN_SRC elisp :tangle example_windows.emacs
;; loading ob-sas
(load "Z:/ob-sas.el")
(require 'ob-sas)
;(require 'ob-R)
;; adding sas language to org babel
(org-babel-do-load-languages
 'org-babel-load-languages
 '((sas . t) ))
;; variable for ob-sas
(setq org-babel-sas-windows t)
(setq org-babel-sas-realsession nil)
(setq org-babel-sas-command "C:\\Progra~1\\SASHome\\SASFoundation\\9.4\\sas.exe")
;; no confirmation for evaluation
(setq org-confirm-babel-evaluate nil)
;; fontify source block (with ess it leading to syntax coloration)
(setq org-src-fontify-natively t)
#+END_SRC
